#!/usr/bin/env Rscript

# Script to analyze CNR profiles, calculate segment scores, and test associations
# This script uses the CNR profile generated by prepare_cnr_data.R

# Load required libraries
library(GSA)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(dplyr)
library(tidyr)

# Set paths
base_dir <- "/bgfs/alee/LO_LAB/Personal/Daisong/APOLLO/DNADX"
output_dir <- file.path(base_dir, "output_v3")
dnadx_dir <- file.path(base_dir, "DNA-based-predictors-of-non-genetic-cancer-phenotypes")
cnr_dir <- "/bgfs/alee/LO_LAB/Personal/Daisong/APOLLO/Tendo/Annotated_cnr_file_500Kb"

# Create output directory if it doesn't exist
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# Load helper functions from DNADX
source(file.path(dnadx_dir, "Rscript", "helper.R"))

# Step 1: Run prepare_cnr_data.R to generate gene-level copy number data
cat("Step 1: Preparing CNR data...\n")

# Function to read CNR file and extract copy number data
read_cnr_file <- function(file_path) {
  # Read CNR file
  cnr_data <- read.delim(file_path, sep = "\t", header = TRUE)
  
  # Extract sample name from file name
  sample_name <- gsub(".annotated.cnr", "", basename(file_path))
  
  # Check if the required columns exist
  call_col <- paste0(sample_name, "_29.Corrected_Call")
  cn_col <- paste0(sample_name, "_29.Corrected_Copy_Number")
  
  if (!call_col %in% colnames(cnr_data) || !cn_col %in% colnames(cnr_data)) {
    cat("Warning: Required columns not found in", file_path, "\n")
    # Try to find alternative column names
    call_cols <- grep("Call", colnames(cnr_data), value = TRUE)
    cn_cols <- grep("Copy_Number", colnames(cnr_data), value = TRUE)
    
    if (length(call_cols) > 0 && length(cn_cols) > 0) {
      call_col <- call_cols[1]
      cn_col <- cn_cols[1]
      cat("Using alternative columns:", call_col, "and", cn_col, "\n")
    } else {
      cat("Error: Cannot find suitable columns in", file_path, "\n")
      return(NULL)
    }
  }
  
  # Create a data frame with the required information
  result <- data.frame(
    chromosome = cnr_data$chromosome,
    start = cnr_data$start,
    end = cnr_data$end,
    log2 = cnr_data$log2,
    call = cnr_data[[call_col]],
    copy_number = cnr_data[[cn_col]],
    gene = cnr_data$gene,
    stringsAsFactors = FALSE
  )
  
  # Return the data frame with sample name
  return(list(sample = sample_name, data = result))
}

# Function to convert CNR data to gene-level copy number
cnr_to_gene_level <- function(cnr_list) {
  # Remove any NULL entries from the list
  cnr_list <- cnr_list[!sapply(cnr_list, is.null)]
  
  if (length(cnr_list) == 0) {
    stop("No valid CNR data found")
  }
  
  # Extract gene information from CNR files
  gene_info <- lapply(cnr_list, function(x) {
    if (is.null(x) || is.null(x$data)) return(NULL)
    
    data.frame(
      chromosome = as.character(x$data$chromosome),
      start = x$data$start,
      end = x$data$end,
      gene = x$data$gene,
      log2 = x$data$log2,
      call = x$data$call,
      copy_number = x$data$copy_number,
      sample = x$sample,
      stringsAsFactors = FALSE
    )
  })
  
  # Remove any NULL entries
  gene_info <- gene_info[!sapply(gene_info, is.null)]
  
  if (length(gene_info) == 0) {
    stop("No valid gene information extracted from CNR files")
  }
  
  # Combine all gene information
  all_gene_info <- do.call(rbind, gene_info)
  
  # Handle missing or NA values
  all_gene_info$gene[is.na(all_gene_info$gene)] <- "-"
  all_gene_info$log2[is.na(all_gene_info$log2)] <- 0
  all_gene_info$copy_number[is.na(all_gene_info$copy_number)] <- 2  # Default diploid
  
  # Split gene column (which may contain multiple genes)
  gene_data <- all_gene_info %>%
    tidyr::separate_rows(gene, sep = ",") %>%
    dplyr::filter(gene != "-") %>%  # Remove regions with no gene annotation
    dplyr::filter(gene != "") %>%   # Remove empty gene names
    dplyr::group_by(gene, sample) %>%
    dplyr::summarize(
      mean_log2 = mean(log2, na.rm = TRUE),
      mean_copy_number = mean(copy_number, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    tidyr::pivot_wider(
      id_cols = gene,
      names_from = sample,
      values_from = c(mean_log2, mean_copy_number)
    )
  
  # Create separate matrices for log2 and copy number
  log2_cols <- grep("mean_log2_", colnames(gene_data), value = TRUE)
  cn_cols <- grep("mean_copy_number_", colnames(gene_data), value = TRUE)
  
  log2_matrix <- as.matrix(gene_data[, log2_cols, drop = FALSE])
  rownames(log2_matrix) <- gene_data$gene
  colnames(log2_matrix) <- gsub("mean_log2_", "", log2_cols)
  
  cn_matrix <- as.matrix(gene_data[, cn_cols, drop = FALSE])
  rownames(cn_matrix) <- gene_data$gene
  colnames(cn_matrix) <- gsub("mean_copy_number_", "", cn_cols)
  
  return(list(log2_matrix = log2_matrix, cn_matrix = cn_matrix))
}

# Read CNR files
cat("Reading CNR files...\n")
cnr_files <- list.files(cnr_dir, pattern = "*.annotated.cnr", full.names = TRUE)

if (length(cnr_files) == 0) {
  stop("No CNR files found in directory:", cnr_dir)
}

cat("Found", length(cnr_files), "CNR files. Processing...\n")

cnr_data_list <- lapply(cnr_files, function(file) {
  cat("Processing", basename(file), "...\n")
  tryCatch({
    read_cnr_file(file)
  }, error = function(e) {
    cat("Error processing", file, ":", e$message, "\n")
    return(NULL)
  })
})

cat("Converting to gene-level copy number...\n")
gene_level_data <- cnr_to_gene_level(cnr_data_list)

# Save the processed data
cat("Saving processed data...\n")
save(gene_level_data, file = file.path(output_dir, "gene_level_cn_data.rda"))

# Step 2: Calculate segment scores using the DNADX script
cat("\nStep 2: Calculating segment scores...\n")

# Load CNA segments GMT file
cna_segments_file <- file.path(dnadx_dir, "data", "CNA_segments.gmt")

# Check if CNA segments GMT file exists
if (!file.exists(cna_segments_file)) {
  stop("CNA segments GMT file does not exist:", cna_segments_file)
}

# Calculate segment scores using the calc_segments function from helper.R
segment_scores <- calc_segments(gene_level_data$cn_matrix, cna_segments_file, method = "mean")

# Save the segment scores
save(segment_scores, file = file.path(output_dir, "segment_scores.rda"))

# Step 3: Test associations between segment scores and signatures
cat("\nStep 3: Testing associations between segment scores and signatures...\n")

# Create a simple function to test associations
test_associations <- function(segment_scores) {
  # Calculate variance of each segment score across samples
  segment_variance <- apply(segment_scores, 1, var)
  
  # Sort segments by variance (higher variance = more informative)
  sorted_segments <- sort(segment_variance, decreasing = TRUE)
  
  # Create a data frame with segment names and their variance
  segment_priority <- data.frame(
    segment = names(sorted_segments),
    variance = sorted_segments,
    stringsAsFactors = FALSE
  )
  
  # Calculate correlations between segments
  cat("Calculating correlations between segments...\n")
  cor_matrix <- cor(t(segment_scores), method = "spearman", use = "pairwise.complete.obs")
  
  # Save the correlation matrix
  write.csv(cor_matrix, file = file.path(output_dir, "segment_correlations.csv"))
  
  # Generate a heatmap of the correlation matrix
  pdf(file.path(output_dir, "segment_correlation_heatmap.pdf"), width = 12, height = 10)
  pheatmap(
    cor_matrix,
    clustering_distance_rows = "correlation",
    clustering_distance_cols = "correlation",
    clustering_method = "ward.D2",
    color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
    fontsize_row = 8,
    fontsize_col = 8
  )
  dev.off()
  
  # Generate a heatmap of the segment scores
  pdf(file.path(output_dir, "segment_scores_heatmap.pdf"), width = 12, height = 10)
  # Select top 30 segments by variance
  top_segments <- head(segment_priority$segment, 30)
  pheatmap(
    segment_scores[top_segments, , drop = FALSE],
    scale = "row",
    clustering_distance_rows = "correlation",
    clustering_distance_cols = "correlation",
    clustering_method = "ward.D2",
    color = colorRampPalette(rev(brewer.pal(11, "RdBu")))(100),
    fontsize_row = 8,
    fontsize_col = 8
  )
  dev.off()
  
  return(segment_priority)
}

# Run the association tests
segment_priority <- test_associations(segment_scores)

# Save the segment priority list
write.csv(segment_priority, file = file.path(output_dir, "segment_priority.csv"), row.names = FALSE)

cat("\nAnalysis complete! Results saved to", output_dir, "\n") 